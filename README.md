# Отчет по практической работе №1 "Работа с git и сервисом GitHub"

В данной практической работе  необходимо настроить пользователя Git как показано на рисунке 1.

Рисунок 1 — Настройка пользователя git

Создать новую директорию **project/**, а в ней два файла **changes.txt** и **readme.md** с помощью терминала как показано на рисунке 2.
![image](https://user-images.githubusercontent.com/49113443/136509595-ae8a382f-5b10-4955-9881-3b48d928de24.png)
Рисунок 2 — Создание директории и файлов в ней

Далее в созданной директории необходимо инициализировать репозиторий командой git init, как показано на рисунке 3.
![image](https://user-images.githubusercontent.com/49113443/136509775-2309dec1-9c1b-48cb-b949-4d283089dc95.png)
Рисунок 3 — Инициализация нового репозитория

Затем произведем создание аналогичного репозитория на сервисе GitHub, и свяжем локальный и удаленный репозитории командой git push -u origin master. Данная процедура  представлена на рисунках 4 и 5 соответсвенно.
![image](https://user-images.githubusercontent.com/49113443/136509841-14da63df-d8c8-4e7a-8220-0aba17242763.png)

Рисунок 4 — Создание нового репозитория на GitHub

![image](https://user-images.githubusercontent.com/49113443/136509986-46047630-f600-48bb-a5f4-8e6c3f9f5535.png)
Рисунок 5 — Связывание локального и удаленного репозитория

Далее нам необходимо создать два файла, README.md, но так как он уже создан, то необходимо добавить в него изменения, для того чтобы git заметил его и файл nogit.txt, который затем необходимо добавить в специальный служебный файл .gitignore и убедиться, что после этого данный файл перестанет отслеживаться системой git. Модифицированный файл README.md необходимо добавить в индекс и записать коммит с сообщением «initial commit». Весь процесс представлен на рисунках c 6 по 8.

![image](https://user-images.githubusercontent.com/49113443/136510012-18985741-d8bc-4722-a1b3-4b1abee71058.png)
Рисунок 6 — Создание файлов

![image](https://user-images.githubusercontent.com/49113443/136510033-aaeb2ef5-9821-45d6-b92b-021427e9595f.png)
Рисунок 7 — Добавление файла в список игнорируемых

![image](https://user-images.githubusercontent.com/49113443/136510047-86d17171-6abe-4ce4-b40e-3dbefef0e421.png)
Рисунок 8 — Запись коммита с сообщением

Далее необходимо снова внести изменения в файл README.md, записать коммит с изменениями, а затем отменить его командой git reset и вновь внести изменения и записать их в коммит, как показано на рисунке 9.

![image](https://user-images.githubusercontent.com/49113443/136510066-1d034030-846d-413f-a27d-5794ecb0de39.png)
Рисунок 9 — Применение операции reset

Далее в текущем репозитории необходимо создать две ветки branch-1 и branch-2 от ветки master. В ветке branch-2 создать файл branch-2.txt и записать изменения в коммит. Затем от ветки branch-2 создать ветку branch-2-1. Эти операции представлены на рисунке 10.

![image](https://user-images.githubusercontent.com/49113443/136510083-75f094fd-67e4-4056-aa66-227ec6fd243c.png)

Рисунок 10 — Создание веток и навигация между ними

Создание SSH-ключей производится с помощью утилиты ssh-keygen, после того, как парольная фраза будет введена ключи будут сохранены в директории .ssh/, которая расположена в домашней директории. Содержимое файла id-rsa.pub необходимо скопировать и уже на сайте сервиса GitHub на странице настроек, во вкладке «SSH и GPG keys» после нажатие на кнопку «Add new SSH key» ввести скопированный ключ, и выбрать название для данного ключа, как показано на рисунке 11.


Рисунок 11 — Добавление нового SSH-ключа 

После этого необходимо синхронизировать все изменения с локальных веток в удаленном репозитории сделать этом можно при помощи команды git push с параметром —set-upstream или его сокращенной версией -u. Процесс синхронизации представлен на рисунке 12.

![image](https://user-images.githubusercontent.com/49113443/136510484-d0c45658-3da0-4463-bc0a-3fd0f65bd8fb.png)

Рисунок 12 — Синхронизация локальных веток с удаленным репозиторием

Создадим файл file-1.txt на ветке branch-1, и file-2-1.txt на ветке branch-2-1. Произведем rebase начала ветки branch-2-1 на ветку branch-1, как показано на рисунке 13. А затем произвдем слияние изменений с ветки branch-2-1 в ветку branch-1. Данная операция показана на рисунке 14.

![image](https://user-images.githubusercontent.com/49113443/136510557-0e3461e7-202e-4c57-a428-0719ed72ed34.png)

Рисунок 13 — Rebase ветки branch-2-1

![image](https://user-images.githubusercontent.com/49113443/136510576-655b0c45-4196-4c90-a5f5-30e422dccfe1.png)

Рисунок 14 — Слияние изменений с ветки branch-2-1 в ветки branch-1

Далее соберем все изменения в ветку master, выставим на нее тэг версии 0.0.1 и загрузим в удаленный репозиторий, но для начала убедимся, что у нас отсутствуют релизы в данном репозитории, как показано на рисунке 15.
![image](https://user-images.githubusercontent.com/49113443/136510605-9b33ea32-b8ca-47a7-b8a6-69c242d085bf.png)
Рисунок 15 — Проверка отсуствия релизов в удаленном репозитории

Теперь можно изменения с последней актуальной ветки, в нашем случае это branch-1 слить в ветку master и выставить тэг версии как показано на рисунке 16. Кроме того произведем загрузку изменений в удаленный репозиторий, и проверим, что теперь в удаленном репозитории появился один релиз с номером версии 0.0.1. 

![image](https://user-images.githubusercontent.com/49113443/136510633-20bab3ac-9203-4efc-a9c0-5a689686d555.png)

Рисунок  16 — Установка тега версии на последний коммит и загрузка в удаленный репозиторий

![image](https://user-images.githubusercontent.com/49113443/136510653-5b281336-bb91-4391-8bc8-16db4e252da5.png)
Рисунок 17 — Проверка наличия релиза на платформе GitHub

Создадим новую ветку request-feature запишем на ней коммит с созданием файла request.txt и загрузим его в удаленный репозиторий как показано на рисунке 18.

![image](https://user-images.githubusercontent.com/49113443/136510670-cf4f8b1b-7b48-4227-b9f0-16060aa304fb.png)
Рисунок 18 — Создания новой ветки для открытия pull-request’a

Теперь изменения в новой ветке можно использовать для создания pull-request’a, как показано на рисунках 19 и 20. Pull-request представляет собой метод слияния веток путем запроса, который может обсуждаться, комментироваться, подвергаться изменению прежде чем будет произведено слияние в целевую ветку.

![image](https://user-images.githubusercontent.com/49113443/136510692-9ec045ca-3181-443b-96b7-e801a4a2d022.png)
Рисунок 19 — Окно сравнения изменений, в котором можно создать pull-request

![image](https://user-images.githubusercontent.com/49113443/136510712-c56c3a28-5a1e-4064-8555-8e38ec886c68.png)
Рисунок 20 — Созданный pull-request

Создадим новую ветку cherry-branch и запишем на ней commit с файлом content.txt. Затем создадим другую ветку clear-branch и на ней также запишем commit c файлом content.txt, но с другим содержимым, а затем выполним операцию cherry-pick, которая перенесет коммит c ветки cherry-branch на ветку clear-branch, как показано на рисунке 21.

![image](https://user-images.githubusercontent.com/49113443/136510736-7a04f436-6b41-4c7a-bc38-4445d0ce95fd.png)
Рисунок 21 — Операция cherry-pick

Наличие двух файлов с одинаковым названием, но разным содержимым вызовет конфликт, который необходимо будет решить вручную открыв файл, и отредактировав его так, чтобы в нем не осталось ничего лишнего. Затем выполним операции добавления в индекс и запись коммита. Содержимое файлов с конфликтующим содержимым и текстом, при записи коммита после решения конфликта представлены на рисунках 22 и 23 соответсвенно.

![image](https://user-images.githubusercontent.com/49113443/136510758-c35488e9-7ab8-403f-aae4-6d6ef3132d29.png)
Рисунок 22 — Файл, в котором возник конфликт

![image](https://user-images.githubusercontent.com/49113443/136510781-ff7e0842-9c9a-484c-9914-3bfde8ad4ae0.png)
Рисунок 23 — Комментарии к коммиту

Как можно видеть на рисунке 24 процесс переноса коммита был произведен корректно.

![image](https://user-images.githubusercontent.com/49113443/136510792-7609427e-ef9e-447b-91f2-fcae47b6757e.png)
Рисунок 24 — История коммитов после операции cherry-pick

**Вывод:** В данной работе мы научились выполнять основные операции с системой контроля версий git, а также с сервисом для хранения и работы с удаленными репозиториями GitHub.
